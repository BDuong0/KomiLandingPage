{"version":3,"sources":["splScrn_content.js"],"names":["splScrn_container","document","querySelector","left_side_imgs","querySelectorAll","right_side_text","Img_Content_Groups","breakpoint","window","matchMedia","mobile_Observer","IntersectionObserver","entries","forEach","entry","isIntersecting","target","style","opacity","threshold","rootMargin","tablet_desktop_Observer","image","watchViewportChange","matches","console","log","img_content_group","unobserve","observe","addListener"],"mappings":"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","file":"splScrn_content.12957b69.js","sourceRoot":"..\\src\\pages\\Story_Synopsis","sourcesContent":["\r\n\r\nconst splScrn_container = document.querySelector('.splScrn-container');\r\nconst left_side_imgs = document.querySelectorAll('.splScrn-container .splScrn-group .splScrn-group__img');\r\nconst right_side_text = document.querySelectorAll('.splScrn-container .splScrn-group .splScrn-group__content-wrap');\r\n\r\nconst Img_Content_Groups = document.querySelectorAll('.splScrn-container .splScrn-group');\r\n\r\nlet breakpoint = window.matchMedia(\"(min-width: 39.5em)\"); //Make sure this is the same as the media querry set in the corresponding scss files\r\n\r\nconst mobile_Observer = new IntersectionObserver(entries => {\r\n    // entries returns an array of one but this is the only way we can access the element in the IntersectionObserver in order to change the element style\r\n    entries.forEach(entry => {\r\n        if (entry.isIntersecting) { // IF branch detected on scroll down                \r\n            entry.target.style.opacity = \"1\";\r\n            \r\n        } else { // ELSE branch deteced on scroll up\r\n            // Need to have the if else for isIntersecting so my observer can work scrolling both up an down\r\n            entry.target.style.opacity = \"0.1\";\r\n        }\r\n    })\r\n\r\n}, \r\n{\r\n    threshold: [0], // Have threshold 0 and rootMargin so no matter how big the img_content_group is the observer will detect at the same point on the viewport\r\n    rootMargin: '-230px 0px -230px 0px' // If I said treshold 0.3 then 0.3 of a bigger img_content_group will ahve a different detecting point than a smaller one which isn't what I want\r\n    \r\n})\r\n\r\nconst tablet_desktop_Observer = new IntersectionObserver(entries => {\r\n    // Similar code structure as mobile_Observer\r\n    entries.forEach(entry => {\r\n        let image = entry.target.querySelector('.splScrn-group__img');\r\n        if (entry.isIntersecting) { \r\n            // console.log(image);\r\n            entry.target.style.opacity = \"1\";\r\n            image.style.opacity = \"1\"; // Need to have this or else my images will pernamently disappear on scroll\r\n                                        // also make sure to have transition property set on the images, not just the parent container so there's no jarring transition between the left side images\r\n        } else { \r\n            entry.target.style.opacity = \"0.1\";\r\n            image.style.opacity = \"0\";\r\n        }\r\n    })\r\n\r\n}, \r\n{\r\n    threshold: [0], // Have threshold 0 and rootMargin so no matter how big the img_content_group is the observer will detect at the same point on the viewport\r\n    rootMargin: '-230px 0px -230px 0px' // If I said treshold 0.3 then 0.3 of a bigger img_content_group will ahve a different detecting point than a smaller one which isn't what I want\r\n    \r\n})\r\n\r\n\r\nfunction watchViewportChange(){\r\n    if (breakpoint.matches) {\r\n        console.log('Tablet/Desktop View');\r\n        \r\n        // Turn off mobile observer for all img_content_group\r\n        Img_Content_Groups.forEach(img_content_group => {\r\n            mobile_Observer.unobserve(img_content_group);\r\n        })\r\n\r\n        // All img_content_groups now observed by tablet_desktop_Observer\r\n        Img_Content_Groups.forEach(img_content_group => {\r\n            tablet_desktop_Observer.observe(img_content_group);\r\n            console.log('watching');\r\n        })\r\n    } else {\r\n        console.log('Mobile View');\r\n\r\n        // Remove tablet_desktop_Observer for all img_content_groups\r\n        Img_Content_Groups.forEach(img_content_group => {\r\n            tablet_desktop_Observer.unobserve(img_content_group);\r\n        })\r\n\r\n        // Switch to the mobile_Observer for all img_cotnent_groups\r\n        Img_Content_Groups.forEach(img_content_group => {\r\n            // Make sure to reset image opacity if fluid change from tablet to mobile \r\n            let image = img_content_group.querySelector('.splScrn-group__img');\r\n            image.style.opacity = \"1\";\r\n\r\n            mobile_Observer.observe(img_content_group);\r\n        })\r\n    }\r\n}\r\n\r\n\r\n// Switch between mobile_Observer and tablet_desktop_Observer based on media querry set in CSS\r\n    // Different observers have different variations of a scroll animation\r\nwatchViewportChange();\r\nbreakpoint.addListener(watchViewportChange);\r\n\r\n// Not perfect\r\n    // When I try to zoom in on tablet/desktop there's a point like at 140% where the opacity of all of my images and content goes to 0\r\n        // I think it's because I'm hitting the tablet_desktop_observer isIntersecting property when I zoom in on the screen.\r\n    // Images and content don't transition in between each other at the same time by a cm or two but 99% of the image and content transitions works.\r\n        // It works on scroll down but there's a slight gap in timing when slowly scrolling up\r\n\r\n"]}