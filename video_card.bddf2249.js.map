{"version":3,"sources":["video_card.js"],"names":["video_cards","document","querySelectorAll","video_card_container","screen_overlay","querySelector","setOnScrollAnimation","element","animation","observer","IntersectionObserver","entries","forEach","entry","isIntersecting","target","style","opacity","addEventListener","unobserve","threshold","observe","video_card__video","store_video","c","setProperty","video_popup_container","parentElement","dataset","visible","popup_wrapper","iframe_video","Array","from","children","includes","append","close_popup_btn","remove","once"],"mappings":"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","file":"video_card.bddf2249.js","sourceRoot":"..\\src","sourcesContent":["const video_cards = document.querySelectorAll('.video-card-wrapper .video-card .video-card__card');\r\nconst video_card_container = document.querySelectorAll('.video-card-wrapper .video-card');\r\n\r\n//body::before -> sceren_overlay from _nav-menu.scss\r\nconst screen_overlay = document.querySelector(\"body\");\r\n\r\n\r\n/*\r\n Intersection Observer for On-Scroll Animation\r\n - Intersection Observer instead of scroll event lsitener b/c of performance \r\n - On-Scroll Animations look decent on Both MObile and Desktop so going to use one piece of code for both mobile & desktop\r\n - On-scroll animations should work scrolling up and scrolling down\r\n*/\r\n\r\n\r\nfunction setOnScrollAnimation(element, animation) {\r\n    // Put Intersection Observer in function for easier to read syntax and reuseable code for other on-scroll animations\r\n\r\n    // On-Scroll Animation\r\n    const observer = new IntersectionObserver(entries => {\r\n        // entries returns an array so have to iterate through it \r\n        entries.forEach(entry => {\r\n        \r\n            if (entry.isIntersecting) { // Observer only works one way. Only forwards.\r\n                // Not going to use a class ( like '.show') to set style\r\n                //console.log(\"Entered w/ Function\");\r\n                \r\n                // CSS style at start opacity 0 and at end of animation opaicty gets permanently set to 1\r\n                // Opacity starts animating b/c of transition property I've set in corresponding CSS file\r\n                entry.target.style.opacity = 1;\r\n                \r\n                // Video Card 1 & Video Card 2 get different animations\r\n                entry.target.style.animation = animation;\r\n                    \r\n                entry.target.addEventListener(\"transitionend\", () => { \r\n                    observer.unobserve(entry.target); // Remove Intersection Observer for that element\r\n                });\r\n            }\r\n        })\r\n        }, \r\n    \r\n        {\r\n        threshold: 0.3, //50% of the element must be visible in viewport before observer gets called\r\n        }\r\n    )\r\n    \r\n    observer.observe(element);\r\n}\r\n\r\nsetOnScrollAnimation(video_card_container[0], \"right_slide_in 1.6s ease-out\");\r\nsetOnScrollAnimation(video_card_container[1], \"left_slide_in 1.6s ease-out\");\r\n//observer.observe(video_card_container[0]);\r\n//observer.observe(video_card_container[1]);\r\n\r\n\r\n/* \r\nRelaod VIdeo Process terribly explained\r\n1. First time open website the iframe video exist in the DOM\r\n2. First time the video pop up is opened and closed the iframe video gets stored into \r\nanother variable called store_video so the video can be accessed throughout the rest of the time the user is on teh website\r\n3. Each time (after the 1 time) the video card is clicked the store_video gets reloaded on popup\r\n- iframe_video gets set to reload_video so I'm able to remove an element and restore the same element later in the program \r\n*/\r\n\r\n/*\r\n   Click Event Listener\r\n*/\r\n// Add click event listener to each video card\r\n// Each video card has their own instance of the click event listener and gets their own attributes & css style set separately\r\nvideo_cards.forEach((video_card__video) => {\r\n    let store_video = \"empty\"; // Each video card has their own reload_variable scope that runs throughout the entire program\r\n    // ^ Reload video each time video card is clicked\r\n    // ^ Create temporary variable to store iframe in to reload later\r\n\r\n    // If I click on the video card itself, make the video popup visible\r\n    video_card__video.addEventListener('click', c => {\r\n        screen_overlay.style.setProperty('--overlay_z-index', 3);\r\n        screen_overlay.style.setProperty('--overlay_opacity', 0.5);   //Activate entire screen overlay\r\n        \r\n        //No matter the order of HTML elements inside video-card the iframe with popup video class will be selected\r\n        // need to declare variables inside the click event listener for videos to be able to switch with no problems\r\n        video_popup_container = video_card__video.parentElement.querySelector('.video-card__popup');\r\n        video_popup_container.dataset.visible = \"show\";\r\n        popup_wrapper = video_popup_container.querySelector('.popup_wrapper'); //Going to need this to add the iframe back in to reload the embeded video\r\n        iframe_video = video_popup_container.querySelector('iframe'); // This is the actual YouTube embed video\r\n\r\n        if (store_video === \"empty\"){ // First time opening the video popup\r\n            iframe_video = video_popup_container.querySelector('iframe'); // This is the actual YouTube embed video\r\n            // First-time I want to select the actual iframe_video that's in the DOM\r\n        } else { // X-times after the first time opening video popup\r\n            iframe_video = store_video;\r\n        }\r\n\r\n        // Reload and Restore Emebed Video that was removed on close\r\n        if (Array.from(popup_wrapper.children).includes(iframe_video) === false) {\r\n            popup_wrapper.append(store_video);\r\n        }\r\n\r\n        // Btn that closes the video pop up. Event listener will only be active during the time that the popup is open\r\n        close_popup_btn = video_popup_container.querySelector('.video_close_btn');\r\n        close_popup_btn.addEventListener('click', c => {\r\n            store_video = iframe_video;\r\n            iframe_video.remove();\r\n            //console.log(iframe_video);\r\n            video_popup_container.dataset.visible = \"hide\";\r\n            \r\n            // Remove whole screen dark overlay\r\n            screen_overlay.style.setProperty('--overlay_opacity', 0);   \r\n            screen_overlay.style.setProperty('--overlay_z-index', -1);     \r\n        }, {once: true} ) // Good for website performance. \r\n                        // Event listener will automatically be removed so eventlistener doesn't happen in the background. \r\n    })\r\n\r\n    \r\n})\r\n\r\n"]}